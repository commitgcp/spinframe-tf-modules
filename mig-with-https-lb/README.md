# Managed Instance Group with an HTTP(s) Load Balancer in Google Cloud Platform

This repository contains a terraform module which creates a Managed Instance Group with an HTTP(s) Load Balancer in Google Cloud Platform.

## Support

For issues please contact: akiva.ashkenazi@comm-it.cloud

<!-- terraform-docs output will go here -->
<!-- BEGINNING OF PRE-COMMIT-TERRAFORM DOCS HOOK -->
## Requirements

No requirements.

## Providers

| Name | Version |
|------|---------|
| <a name="provider_google"></a> [google](#provider\_google) | 5.23.0 |

## Modules

| Name | Source | Version |
|------|--------|---------|
| <a name="module_instance_template"></a> [instance\_template](#module\_instance\_template) | terraform-google-modules/vm/google//modules/instance_template | ~> 11.0 |
| <a name="module_lb_http"></a> [lb\_http](#module\_lb\_http) | GoogleCloudPlatform/lb-http/google | ~> 10.2.0 |
| <a name="module_mig"></a> [mig](#module\_mig) | terraform-google-modules/vm/google//modules/mig | ~> 11.1.0 |

## Resources

| Name | Type |
|------|------|
| [google_compute_managed_ssl_certificate.default](https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_managed_ssl_certificate) | resource |
| [google_service_account.mig_sa](https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/service_account) | resource |

## Inputs

| Name | Description | Type | Default | Required |
|------|-------------|------|---------|:--------:|
| <a name="input_domains"></a> [domains](#input\_domains) | Domains for which a managed SSL certificate will be valid. | `list(string)` | n/a | yes |
| <a name="input_instance_template"></a> [instance\_template](#input\_instance\_template) | Configuration for the instance template includes:<br>- access\_config: Access configurations, i.e., IPs via which the VM instance can be accessed via the Internet.<br>- additional\_disks: List of additional disk configurations.<br>- alias\_ip\_range: An array of alias IP ranges for this network interface.<br>- auto\_delete: Whether the disk will be auto-deleted when the instance is deleted.<br>- automatic\_restart: Specifies whether the instance should be automatically restarted if it is terminated by Compute Engine.<br>- can\_ip\_forward: Allow IP forwarding for the instances.<br>- disk\_encryption\_key: The id of the encryption key that is stored in Google Cloud KMS to use to encrypt all the disks on this instance.<br>- disk\_labels: A map of labels to attach to the disk.<br>- disk\_size\_gb: The size of the disk attached to each instance, specified in GB.<br>- disk\_type: The type of the disk attached to each instance.<br>- gpu: GPU information. Type and count of GPU to attach to the instance template.<br>- ipv6\_access\_config: IPv6 access configurations.<br>- machine\_type: The machine type to use for the compute instances.<br>- maintenance\_interval: Specifies the frequency of planned maintenance events.<br>- metadata: Metadata key/value pairs to make available from within the compute instances.<br>- min\_cpu\_platform: Specifies a minimum CPU platform.<br>- network\_ip: Private IP address to assign to the instance if desired.<br>- on\_host\_maintenance: Instance availability Policy.<br>- resource\_policies: A list of self\_links of resource policies to attach to the instance.<br>- source\_image: The source image for the disks attached to the compute instances.<br>- source\_image\_family: The family of the source image for the disk.<br>- source\_image\_project: The project of the source image for the disk.<br>- stack\_type: The stack type for this network interface to identify whether the IPv6 feature is enabled or not.<br>- startup\_script: The startup script to run on each compute instance.<br>- subnetwork: The subnetwork to deploy to.<br>- tags: A list of tags to attach to the compute instances. | <pre>object({<br>    access_config = optional(list(object({<br>      nat_ip       = string<br>      network_tier = string<br>    })), [])<br>    additional_disks = optional(list(object({<br>      device_name  = string<br>      disk_labels  = map(string)<br>      disk_name    = string<br>      disk_type    = string<br>      auto_delete  = bool<br>      boot         = bool<br>      disk_size_gb = number<br>      labels       = map(string)<br>    })), [])<br>    alias_ip_range = optional(object({<br>      ip_cidr_range         = string<br>      subnetwork_range_name = string<br>    }), null)<br>    auto_delete         = optional(bool, true)<br>    automatic_restart   = optional(bool, true)<br>    can_ip_forward      = optional(bool, false)<br>    disk_encryption_key = optional(string, null)<br>    disk_labels         = optional(map(string), {})<br>    disk_size_gb        = optional(number, 10)<br>    disk_type           = optional(string, "pd-standard")<br>    gpu = optional(object({<br>      type  = string<br>      count = number<br>    }), null)<br>    ipv6_access_config = optional(list(object({<br>      network_tier = string<br>    })), [])<br>    machine_type         = optional(string, "e2-micro")<br>    maintenance_interval = optional(string, null)<br>    metadata             = optional(map(string), {})<br>    min_cpu_platform     = optional(string, null)<br>    network_ip           = optional(string, "")<br>    on_host_maintenance  = optional(string, "MIGRATE")<br>    resource_policies    = optional(list(string), [])<br>    source_image         = optional(string, "debian-cloud/debian-9")<br>    source_image_family  = optional(string, null)<br>    source_image_project = optional(string, null)<br>    stack_type           = optional(string, null)<br>    startup_script       = optional(string, "")<br>    subnetwork           = optional(string, "")<br>    tags                 = optional(list(string), [])<br>  })</pre> | n/a | yes |
| <a name="input_labels"></a> [labels](#input\_labels) | The labels to attach to resources created by this module. | `map(string)` | `{}` | no |
| <a name="input_load_balancer"></a> [load\_balancer](#input\_load\_balancer) | Configuration for the load balancer includes:<br>- address: Existing IPv4 address to use (the actual IP address value).<br>- certificate: Content of the SSL certificate. Requires SSL to be true and create\_ssl\_certificate to be true.<br>- certificate\_map: Certificate Map ID in format projects/{project}/locations/global/certificateMaps/{name}.<br>- create\_address: Create a new global IPv4 address.<br>- create\_http\_forward: Whether to create an HTTP forward rule for the load balancer.<br>- create\_ipv6\_address: Allocate a new IPv6 address. Conflicts with 'ipv6\_address'.<br>- create\_ssl\_certificate: If true, create certificate using private\_key/certificate.<br>- create\_url\_map: Set to false if url\_map variable is provided.<br>- enable\_ipv6: Enable IPv6 address on the CDN load-balancer.<br>- firewall\_networks: Names of the networks to create firewall rules in.<br>- firewall\_projects: Names of the projects to create firewall rules in.<br>- http\_forward\_port: The port for the HTTP forward rule.<br>- https\_port: The HTTPS port for the load balancer.<br>- https\_redirect: Enable HTTPS redirect for the load balancer.<br>- ipv6\_address: An existing IPv6 address to use (the actual IP address value).<br>- load\_balancing\_scheme: Load balancing scheme type (EXTERNAL, EXTERNAL\_MANAGED, INTERNAL\_SELF\_MANAGED).<br>- managed\_ssl\_certificate\_domains: List of domains for managed SSL certificates.<br>- private\_key: Content of the private SSL key.<br>- random\_certificate\_suffix: Bool to enable/disable random certificate name generation.<br>- server\_tls\_policy: The resource URL for the server TLS policy to associate with the https proxy service.<br>- ssl: Enable SSL for the load balancer.<br>- ssl\_certificates: SSL cert self\_link list.<br>- ssl\_policy: Selfink to SSL Policy.<br>- target\_service\_accounts: List of target service accounts for health check firewall rule.<br>- target\_tags: List of target tags for health check firewall rule.<br>- url\_map: The url\_map resource to use. Default is to send all traffic to first backend. | <pre>object({<br>    address                         = optional(string, null)<br>    certificate                     = optional(string, null)<br>    certificate_map                 = optional(string, null)<br>    create_address                  = optional(bool, true)<br>    create_http_forward             = optional(bool, true)<br>    create_ipv6_address             = optional(bool, false)<br>    create_ssl_certificate          = optional(bool, false)<br>    create_url_map                  = optional(bool, true)<br>    enable_ipv6                     = optional(bool, false)<br>    firewall_networks               = optional(list(string), ["default"])<br>    firewall_projects               = optional(list(string), ["default"])<br>    http_forward_port               = optional(number, 80)<br>    https_port                      = optional(number, 443)<br>    https_redirect                  = optional(bool, false)<br>    ipv6_address                    = optional(string, null)<br>    load_balancing_scheme           = optional(string, "EXTERNAL_MANAGED")<br>    managed_ssl_certificate_domains = optional(list(string), [])<br>    private_key                     = optional(string, null)<br>    random_certificate_suffix       = optional(bool, false)<br>    server_tls_policy               = optional(string, null)<br>    ssl                             = optional(bool, false)<br>    #ssl_certificates                 = optional(list(string), [])<br>    ssl_policy              = optional(string, null)<br>    target_service_accounts = optional(list(string), [])<br>    target_tags             = optional(list(string), [])<br>    url_map                 = optional(string, null)<br>  })</pre> | n/a | yes |
| <a name="input_load_balancer_backend"></a> [load\_balancer\_backend](#input\_load\_balancer\_backend) | Configuration for the load balancer backend includes:<br>- affinity\_cookie\_ttl\_sec: Lifetime of cookies in seconds if session\_affinity is GENERATED\_COOKIE.<br>- backend\_port: Port of backend service for load balancer.<br>- backend\_port\_name: Name of port of backend service for load balancer.<br>- backend\_protocol: The protocol this BackendService uses to communicate with backends.<br>- cdn\_policy: CDN config for load balancer.<br>- compression\_mode: Compress text responses using Brotli or gzip compression.<br>- custom\_request\_headers: Headers that the HTTP/S load balancer should add to proxied requests.<br>- custom\_response\_headers: Headers that the HTTP/S load balancer should add to proxied responses.<br>- enable\_cdn: Enable CDN for load balancer backend.<br>- http\_health\_check: HTTP health check configuration.<br>- iap\_config: IAP config for load balancer.<br>- log\_config: Log config for load balancer.<br>- security\_policy: The security policy associated with this backend service.<br>- session\_affinity: Type of session affinity to use.<br>- timeout\_sec: How many seconds to wait for the backend before considering it a failed request. | <pre>object({<br>    affinity_cookie_ttl_sec = optional(number, null)<br>    backend_port            = optional(number)<br>    backend_port_name       = optional(string)<br>    backend_protocol        = optional(string, "HTTP")<br>    cdn_policy = optional(object({<br>      cache_mode                   = optional(string)<br>      signed_url_cache_max_age_sec = optional(string)<br>      default_ttl                  = optional(number)<br>      max_ttl                      = optional(number)<br>      client_ttl                   = optional(number)<br>      negative_caching             = optional(bool)<br>      negative_caching_policy = optional(object({<br>        code = optional(number)<br>        ttl  = optional(number)<br>      }))<br>      serve_while_stale = optional(number)<br>      cache_key_policy = optional(object({<br>        include_host           = optional(bool)<br>        include_protocol       = optional(bool)<br>        include_query_string   = optional(bool)<br>        query_string_blacklist = optional(list(string))<br>        query_string_whitelist = optional(list(string))<br>        include_http_headers   = optional(list(string))<br>        include_named_cookies  = optional(list(string))<br>      }))<br>      bypass_cache_on_request_headers = optional(list(string))<br>    }), {})<br>    compression_mode        = optional(string, "")<br>    custom_request_headers  = optional(list(string), [])<br>    custom_response_headers = optional(list(string), [])<br>    enable_cdn              = optional(bool, false)<br>    http_health_check = optional(object({<br>      check_interval_sec  = optional(number)<br>      healthy_threshold   = optional(number)<br>      timeout_sec         = optional(number)<br>      unhealthy_threshold = optional(number)<br>      port                = optional(number)<br>      request_path        = optional(string)<br>      logging             = optional(bool)<br>      protocol            = optional(string)<br>      port_specification  = optional(string)<br>      proxy_header        = optional(string)<br>      port_name           = optional(string)<br>      request             = optional(string)<br>      response            = optional(string)<br>      host                = optional(string)<br>      }), {<br>      check_interval_sec  = 30<br>      healthy_threshold   = 1<br>      timeout_sec         = 5<br>      unhealthy_threshold = 5<br>      port                = 80<br>      request_path        = "/"<br>      logging             = false<br>    })<br>    iap_config = optional(object({<br>      enable               = bool<br>      oauth2_client_id     = optional(string)<br>      oauth2_client_secret = optional(string)<br>    }), { enable = false })<br>    log_config = optional(object({<br>      enable      = optional(bool)<br>      sample_rate = optional(number)<br>    }), { enable = false })<br>    security_policy  = optional(string, "")<br>    session_affinity = optional(string, "NONE")<br>    timeout_sec      = optional(number, 30)<br>  })</pre> | n/a | yes |
| <a name="input_managed_instance_group"></a> [managed\_instance\_group](#input\_managed\_instance\_group) | Configuration for the Managed Instance Group includes:<br>- autoscaling\_cpu: Autoscaling based on CPU utilization.<br>- autoscaling\_enabled: Creates an autoscaler for the managed instance group.<br>- autoscaling\_lb: Autoscaling based on load balancing utilization.<br>- autoscaling\_metric: Autoscaling based on custom metric.<br>- autoscaling\_mode: Operating mode of the autoscaling policy.<br>- autoscaling\_scale\_in\_control: Autoscaling scale-in control parameters.<br>- cooldown\_period: The number of seconds that the autoscaler should wait before it starts collecting information from a new instance.<br>- distribution\_policy\_target\_shape: The shape to which the group converges.<br>- distribution\_policy\_zones: The distribution policy, i.e., which zone(s) should instances be created in.<br>- health\_check: Health check configuration.<br>- max\_replicas: The maximum number of instances that the autoscaler can scale up to.<br>- min\_replicas: The minimum number of replicas that the autoscaler can scale down to.<br>- scaling\_schedules: Autoscaling scaling schedule block.<br>- stateful\_disks: List of stateful disks created on the instances that will be preserved on instance delete.<br>- stateful\_ips: List of stateful IPs created on the instances that will be preserved on instance delete.<br>- target\_pools: The target load balancing pools to assign this group to.<br>- target\_size: The target size for the managed instance group.<br>- update\_policy: The rolling update policy.<br>- wait\_for\_instances: Whether to wait for all instances to be created/updated before returning. | <pre>object({<br>    autoscaling_cpu     = optional(list(map(string)), [])<br>    autoscaling_enabled = optional(bool, false)<br>    autoscaling_lb      = optional(list(map(string)), [])<br>    autoscaling_metric  = optional(list(map(string)), [])<br>    autoscaling_mode    = optional(string, "ON")<br>    autoscaling_scale_in_control = optional(object({<br>      fixed_replicas   = number<br>      percent_replicas = number<br>      time_window_sec  = number<br>      }), {<br>      fixed_replicas   = null<br>      percent_replicas = null<br>      time_window_sec  = null<br>    })<br>    cooldown_period                  = optional(number, 60)<br>    distribution_policy_target_shape = optional(string, "EVEN")<br>    distribution_policy_zones        = optional(list(string), [])<br>    health_check = optional(object({<br>      type                = string<br>      initial_delay_sec   = number<br>      check_interval_sec  = number<br>      healthy_threshold   = number<br>      timeout_sec         = number<br>      unhealthy_threshold = number<br>      response            = string<br>      proxy_header        = string<br>      port                = number<br>      request             = string<br>      request_path        = string<br>      host                = string<br>      enable_logging      = bool<br>      }), {<br>      "check_interval_sec" : 30,<br>      "enable_logging" : false,<br>      "healthy_threshold" : 1,<br>      "host" : "",<br>      "initial_delay_sec" : 30,<br>      "port" : 80,<br>      "proxy_header" : "NONE",<br>      "request" : "",<br>      "request_path" : "/",<br>      "response" : "",<br>      "timeout_sec" : 10,<br>      "type" : "",<br>      "unhealthy_threshold" : 5<br>    })<br>    max_replicas = optional(number, 10)<br>    min_replicas = optional(number, 1)<br>    scaling_schedules = optional(list(object({<br>      disabled              = bool<br>      duration_sec          = number<br>      min_required_replicas = number<br>      name                  = string<br>      schedule              = string<br>      time_zone             = string<br>    })), [])<br>    stateful_disks = optional(list(object({<br>      device_name = string<br>      delete_rule = string<br>    })), [])<br>    stateful_ips = optional(list(object({<br>      interface_name = string<br>      delete_rule    = string<br>      is_external    = bool<br>    })), [])<br>    target_pools = optional(list(string), [])<br>    target_size  = optional(number, 1)<br>    update_policy = optional(list(object({<br>      type                           = string<br>      instance_redistribution_type   = string<br>      minimal_action                 = string<br>      most_disruptive_allowed_action = string<br>      max_surge_percent              = number<br>      max_surge_fixed                = number<br>      max_unavailable_percent        = number<br>      max_unavailable_fixed          = number<br>      min_ready_sec                  = number<br>      replacement_method             = string<br>    })), [])<br>    wait_for_instances = optional(bool, false)<br>  })</pre> | n/a | yes |
| <a name="input_name"></a> [name](#input\_name) | The name prefix for all resources. | `string` | n/a | yes |
| <a name="input_network"></a> [network](#input\_network) | Network for resources to be created in | `string` | `"default"` | no |
| <a name="input_project_id"></a> [project\_id](#input\_project\_id) | The GCP project ID. | `string` | n/a | yes |
| <a name="input_region"></a> [region](#input\_region) | The GCP region where resources will be created. | `string` | n/a | yes |

## Outputs

| Name | Description |
|------|-------------|
| <a name="output_instance_group"></a> [instance\_group](#output\_instance\_group) | The URL of the Managed Instance Group. |
| <a name="output_load_balancer_ip"></a> [load\_balancer\_ip](#output\_load\_balancer\_ip) | The external IP of the HTTP(s) Load Balancer. |
| <a name="output_mig_service_account"></a> [mig\_service\_account](#output\_mig\_service\_account) | The email of the service account which runs the Managed Instance Group |
<!-- END OF PRE-COMMIT-TERRAFORM DOCS HOOK -->